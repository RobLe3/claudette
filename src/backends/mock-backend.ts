// Mock Backend for Testing and Development
import { BaseBackend } from './base';
import { ClaudetteRequest, ClaudetteResponse, BackendSettings } from '../types/index';

export interface MockBackendSettings extends BackendSettings {
  // Mock-specific settings
  simulateLatency?: number;
  simulateFailure?: boolean;
  mockResponses?: string[];
}

export class MockBackend extends BaseBackend {
  private responseIndex: number = 0;
  private mockSettings: MockBackendSettings;

  constructor(settings: MockBackendSettings) {
    super('mock-backend', settings);
    this.mockSettings = settings;
  }

  async isAvailable(): Promise<boolean> {
    // Mock backend is always available unless explicitly disabled
    return !this.mockSettings.simulateFailure;
  }

  async send(request: ClaudetteRequest): Promise<ClaudetteResponse> {
    const startTime = Date.now();

    // Simulate latency if configured
    if (this.mockSettings.simulateLatency && this.mockSettings.simulateLatency > 0) {
      await new Promise(resolve => setTimeout(resolve, this.mockSettings.simulateLatency));
    }

    // Simulate failure if configured
    if (this.mockSettings.simulateFailure) {
      throw new Error('Mock backend simulated failure');
    }

    // Generate mock response
    const mockResponses = this.mockSettings.mockResponses || [
      'This is a mock response from the test backend.',
      'Mock backend is working correctly.',
      'Test response generated by mock backend.',
      'Mock AI response for testing purposes.'
    ];

    const responseContent = mockResponses[this.responseIndex % mockResponses.length];
    this.responseIndex++;

    const latency = Date.now() - startTime;
    const inputTokens = this.estimateTokens(request.prompt + (request.files?.join('') || ''));
    const outputTokens = this.estimateTokens(responseContent);
    const cost = (inputTokens + outputTokens) * this.config.cost_per_token;

    const response: ClaudetteResponse = {
      content: responseContent,
      backend_used: this.name,
      tokens_input: inputTokens,
      tokens_output: outputTokens,
      cost_eur: cost,
      latency_ms: latency,
      cache_hit: false,
      metadata: {
        mock: true,
        request_id: request.metadata?.request_id || 'mock-request',
        model: this.config.model || 'mock-model-v1'
      }
    };

    return response;
  }

  /**
   * Simple token estimation for mock purposes
   */
  protected estimateTokens(text: string): number {
    // Simple estimation: ~4 characters per token
    return Math.ceil(text.length / 4);
  }

  /**
   * Get backend information
   */
  getInfo() {
    return {
      name: this.name,
      type: 'self_hosted' as const,
      model: this.config.model || 'mock-model-v1',
      priority: this.config.priority || 999,
      healthy: !this.mockSettings.simulateFailure,
      available: true,
      mock: true,
      cost_per_token: this.config.cost_per_token,
      settings: this.mockSettings
    };
  }

  /**
   * Check backend health status
   */
  async checkHealth(): Promise<{ status: string; responseTime: number; error?: string }> {
    const startTime = Date.now();
    
    try {
      if (this.mockSettings.simulateFailure) {
        return {
          status: 'unhealthy',
          responseTime: Date.now() - startTime,
          error: 'Mock backend simulated failure'
        };
      }

      // Simulate some latency for health check
      if (this.mockSettings.simulateLatency) {
        const delay = Math.min(this.mockSettings.simulateLatency, 100);
        await new Promise(resolve => setTimeout(resolve, delay));
      }

      return {
        status: 'healthy',
        responseTime: Date.now() - startTime
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Get backend configuration
   */
  getConfiguration(): Record<string, any> {
    return {
      name: this.name,
      type: 'mock',
      model: this.config.model || 'mock-model-v1',
      priority: this.config.priority || 999,
      cost_per_token: this.config.cost_per_token,
      simulateLatency: this.mockSettings.simulateLatency,
      simulateFailure: this.mockSettings.simulateFailure,
      mockResponses: this.mockSettings.mockResponses?.length || 4,
      available: true,
      mock: true
    };
  }

  /**
   * Test the mock backend
   */
  async test(): Promise<boolean> {
    try {
      const testRequest: ClaudetteRequest = {
        prompt: 'Test prompt for mock backend',
        files: [],
        options: {},
        metadata: { test: true }
      };

      const response = await this.send(testRequest);
      return response.content.length > 0 && response.backend_used === this.name;
    } catch (error) {
      return false;
    }
  }
}